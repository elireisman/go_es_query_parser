package grammar

import "github.com/elireisman/go_es_query_parser/utils"

type DSL2ES Peg {
    Queries     *utils.QueryStack
    Values      *utils.ValueStack
    IsFilter    bool
    Verbose     bool
}


# Rules

# TODO: does Finalize() run before or after the rule matching?
Result <- SP? Query Complete !.

Complete <- SP? { p.Queries.Finalize(p.Values.PopGroup()) }
Query    <- AndExprs / OrExprs / Expr
AndExprs <- Expr (SP AND SP Expr)+
OrExprs  <- Expr (SP OR SP Expr)+

Expr     <- GroupOrNot / TermOrNot
TermOrNot <- NotCheck Term
Term     <- KeyValue / Single
NotCheck <- (Not / Empty) SP?
Not      <- NOT { p.Values.SetNegation(true) }
Empty    <- !NOT { p.Values.SetNegation(false) }

GroupOrNot      <- GroupPrefix GroupSuffix
GroupPrefix     <- NotGroupStart / GroupStart
GroupStart      <- NOT SP? OPENPAREN { p.Queries.Push(true) }
NotGroupStart   <- !NOT OPENPAREN { p.Queries.Push(false) }
GroupSuffix     <- SP? Query SP? CLOSEPAREN

KeyValue <- Key COLON Value
Key      <- < [a-z]+ > { p.Values.SetField(buffer[begin:end]) }
Value    <- EXISTS / Range / BOOL / Phrase / Date / Number / Word

Single       <- DefaultField (Phrase / Number / Word)
DefaultField <- { p.Values.SetField("_all") }

Range  <- RANGEOP Number / RANGEOP Date
Date   <- < Year SEP Month SEP Day > { if p.Values.Peek().RangeOp != utils.NoOp { p.Values.Range(buffer[begin:end]) } else { p.Values.Term(buffer[begin:end]) } }
Phrase <- DQ < [^"]+ > DQ { p.Values.Phrase(buffer[begin:end]) }


# Token Matchers

Word   <- < [a-zA-Z_] [a-zA-Z0-9_]* > { p.Values.Term(buffer[begin:end]) }

Number <- < [0-9]+ > { if p.Values.Peek().RangeOp != utils.NoOp { p.Values.Range(buffer[begin:end]) } else { p.Values.Number(buffer[begin:end]) } }

Month  <- '0' [1-9] / '1' [0-2]
Year   <- [12] [0-9] [0-9] [0-9]
Day    <- '0' [1-9] / [12] [0-9] / '3' [01]

OPENPAREN  <- '(' { p.Values.StartGroup() }
CLOSEPAREN <- ')' { p.Queries.Compose(p.Values.PopGroup()) }

EXISTS  <- '?' { p.Values.Exists() }
SEP     <- '/'
COLON   <- ':'
DQ      <- '"'
NOT     <- 'NOT' / '!'

BOOL    <- 'true' / 'false' { p.Values.Boolean(buffer[begin:end]) }

AND     <- 'AND' { p.Queries.Current().SetOper(utils.And) }
OR      <- 'OR' { p.Queries.Current().SetOper(utils.Or) }

RANGEOP <- GTE / LTE / GT / LT
GTE     <- < '>=' > { p.Values.SetRangeOp(buffer[begin:end]) }
LTE     <- < '<=' > { p.Values.SetRangeOp(buffer[begin:end]) }
GT      <- < '>' >  { p.Values.SetRangeOp(buffer[begin:end]) }
LT      <- < '<' >  { p.Values.SetRangeOp(buffer[begin:end]) }

SP      <- [ \t\r\n]+

