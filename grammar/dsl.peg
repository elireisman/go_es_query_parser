package grammar

import "github.com/elireisman/go_es_query_parser/utils"

type DSL2ES Peg {
    Queries     *utils.QueryStack 
    Values      *utils.ValueStack
    IsFilter    bool
    Verbose     bool
}


# Rules

Result <- Query !. { p.Queries.Finalize(p.Values.PopGroup()) }

Query <- AndExprs / OrExprs / Expr

AndExprs <- Expr (SP AND SP Expr)+

OrExprs <- Expr (SP OR SP Expr)+

Expr <- NegatedTerm / Term

NegatedTerm <- NOT KeyValue { p.Values.SetNegation(true) }
            /  NOT Word { p.Values.SetNegation(true) }
            /  NOTOPENPAREN SP? Query SP? CLOSEPAREN

Term <- KeyValue { p.Values.SetNegation(false) }
     /  Word { p.Values.SetNegation(false) }
     /  OPENPAREN SP? Query SP? CLOSEPAREN

KeyValue <- Key COLON Value

Key <- [a-z]+ { p.Values.SetField(buffer[begin:end]) }

Value <- Range / Boolean / Phrase / Date / Number / Simple

Range <- RANGEOP Number / RANEGOP Date

Date <- <Year SEP Month SEP Day> { if p.Values.Peek() != nil && p.Values.Peek().RangeOp != utils.NoOp { p.Values.Range(buffer[begin:end]) } else { p.Values.Term(buffer[begin:end]) } }

Phrase <- DQ <[^"]+> DQ { p.Values.Phrase(buffer[begin:end]) }

Month <- '0' [1-9] / '1' [0-2]

Year <- [12] [0-9] [0-9] [0-9]

Day <- '0' [1-9] / [12] [0-9] / '3' [01] 


# Token Matchers

OPENPAREN <- '(' { p.Queries.Push(false) ; p.Values.StartGroup() }

NOTOPENPAREN <- NOT OPENPAREN { p.Queries.Push(true) ; p.Values.StartGroup() }

CLOSEPAREN <- ')' { p.Queries.Compose(p.Values.PopGroup()) }

SEP <- '/'

COLON <- ':'

DQ <- '"'

NOT <- 'NOT'

AND <- 'AND' { p.Queries.Current().SetOper(utils.And) }

OR <- 'OR' { p.Queries.Current().SetOper(utils.Or) }

RANGEOP <- <'<='> / <'>='> / <'<'> / <'>'> { p.Values.SetRangeOp(buffer[begin:end]) }

SP <- [ \t\r\n]+

Boolean <- 'true' / 'false' { p.Values.Boolean(buffer[begin:end]) }

Simple <- [a-zA-Z_] [a-zA-Z0-9_]* { p.Values.Term(buffer[begin:end]) }

Word <- [a-zA-Z_] [a-zA-Z0-9_]* { p.Values.Match(buffer[begin:end]) }

Number <- [0-9]+ { if p.Values.Peek() != nil && p.Values.Peek().RangeOp != utils.NoOp { p.Values.Range(buffer[begin:end]) } else { p.Values.Number(buffer[begin:end]) } }
